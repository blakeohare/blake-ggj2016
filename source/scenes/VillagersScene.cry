class VillagersScene : AbstractScene {
	constructor(enable_wizard) : base() {
		this.is_both = enable_wizard;
		this.monster = new Sprite('M', .5, .1);
		
		this.villagers = [];
		for (i = 1; i <= 7; ++i) {
			this.villagers.add(new Sprite('V' + i, .1 + i / 10.0, .7));
		}
		
		this.sprites = this.villagers + [this.monster];
		
		this.sprites_by_id = {};
		
		for (sprite : this.sprites) {
			this.sprites_by_id[sprite.id] = sprite;
		}
		
		this.bounds = [0, 0, SCREEN_WIDTH, SCREEN_HEIGHT];
		
		this.device_ids_configured = [];
		for (i = 0; i < $gamepad_count(); ++i) {
			device = $gamepad_get_device(i);
			device_id = device.id;
			if (device_id != null) {
				this.device_ids_configured.add(device_id);
			}
		}
		
		this.bg = IMAGES.get('island.png');
		
		this.monster.faces = {
			'normal': {
				's': IMAGES.get('monster/s.png'),
				'se': IMAGES.get('monster/se.png'),
				'sw': IMAGES.get('monster/sw.png'),
				'e': IMAGES.get('monster/e.png'),
				'w': IMAGES.get('monster/w.png'),
			},
			'attacking': {
				's': IMAGES.get('monster/fire/s.png'),
				'se': IMAGES.get('monster/fire/se.png'),
				'sw': IMAGES.get('monster/fire/sw.png'),
				'e': IMAGES.get('monster/fire/e.png'),
				'w': IMAGES.get('monster/fire/w.png'),
			},
		};
		
		
		
		this.counter = 0;
	}
	
	function update(events, mx, my) {
		for (event : events) {
			if (event.is_gamepad && event.name == 'attack') {
				player_id = CONTEXT.config_id_to_game_id.get(event.device.id, null);
				if (player_id != null) {
					sprite = this.sprites_by_id.get(player_id, null);
					if (sprite.is_monster) {
						sprite.is_attacking = event.value;
					} else if (sprite.is_villager) {
						
					}
				}
			}
		}
		
		for (device_id : this.device_ids_configured) {
			dir = $gamepad_get_state(device_id, 'dir');
			
			player_id = CONTEXT.config_id_to_game_id.get(device_id, null);
			if (player_id != null) {
				sprite = this.sprites_by_id.get(player_id, null);
				if (sprite != null) {
					sprite.dx = dir[0] * sprite.v;
					sprite.dy = dir[1] * sprite.v;
				}
			}
		}
		
		if (!this.monster.is_dead && this.monster.is_attacking) {
			if (this.counter % 3 == 0) {
				monster = this.monster;
				angle = 3.14159 * 2 / 8;
				theta = monster.theta + angle * ($random() - .5);
				fire = new Sprite('fire', monster.x, monster.y - .00001);
				dx = $cos(theta) * fire.v;
				dy = -$sin(theta) * fire.v;
				fire.locked_dxdy = [dx, dy];
				this.sprites.add(fire);
			}
		}
		
		new_sprites = [];
		for (sprite : this.sprites) {
			sprite.update();
			if (!sprite.is_dead) {
				new_sprites.add(sprite);
			}
		}
		this.sprites = new_sprites;
		
		this.counter++;
	}
	
	function render(rc) {
		$gfx_blit_image(this.bg, 0, 0);
		
		sorted_sprites = this.quick_sort(this.sprites);
		
		for (sprite : sorted_sprites) {
			sprite.window_bounds = this.bounds;
			sprite.render(rc);
		}
	}
	
	function quick_sort(sprites) {
		if (sprites.length < 3) {
			if (sprites.length == 2) {
				if (sprites[0].y > sprites[1].y) return sprites[::-1];
			}
			return sprites;
		}
		
		pivot = sprites[0].y;
		left = [];
		right = [];
		for (i = sprites.length - 1; i > 0; --i) {
			sprite = sprites[i];
			if (sprites[i].y < pivot) {
				left.add(sprite);
			} else {
				right.add(sprite);
			}
		}
		left = this.quick_sort(left);
		right = this.quick_sort(right);
		output = left + [sprites[0]];
		output.concat(right);
		return output;
	}
}