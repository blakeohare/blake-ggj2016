
ARENA_BOUNDS = [51.0 / SCREEN_WIDTH, 333.0 / SCREEN_HEIGHT, 925.0 / SCREEN_WIDTH, 525.0 / SCREEN_HEIGHT];

MONSTER_START = [.5, 234.0 / SCREEN_HEIGHT];

class VillagersScene : AbstractScene {
	constructor(enable_wizard) : base() {
		this.is_both = enable_wizard;
		this.monster = new Sprite('M', MONSTER_START[0], MONSTER_START[1]);
		
		this.villagers = [];
		for (i = 1; i <= 7; ++i) {
			this.villagers.add(new Sprite('V' + i, .1 + i / 10.0, .7));
		}
		
		this.sprites = this.villagers + [this.monster];
		
		this.sprites_by_id = {};
		
		for (sprite : this.sprites) {
			this.sprites_by_id[sprite.id] = sprite;
		}
		
		this.bounds = [0, 0, SCREEN_WIDTH, SCREEN_HEIGHT];
		
		this.device_ids_configured = [];
		for (i = 0; i < $gamepad_count(); ++i) {
			device = $gamepad_get_device(i);
			device_id = device.id;
			if (device_id != null) {
				this.device_ids_configured.add(device_id);
			}
		}
		
		this.bg = IMAGES.get('island.png');
		
		this.monster.faces = {
			'normal': {
				's': IMAGES.get('monster/s.png'),
				'se': IMAGES.get('monster/se.png'),
				'sw': IMAGES.get('monster/sw.png'),
				'e': IMAGES.get('monster/e.png'),
				'w': IMAGES.get('monster/w.png'),
			},
			'attacking': {
				's': IMAGES.get('monster/fire/s.png'),
				'se': IMAGES.get('monster/fire/se.png'),
				'sw': IMAGES.get('monster/fire/sw.png'),
				'e': IMAGES.get('monster/fire/e.png'),
				'w': IMAGES.get('monster/fire/w.png'),
			},
		};
		
		this.counter = 0;
	}
	
	function throw_spear(sprite) {
		sprite.spear_cooldown = 5;
		theta = sprite.theta;
		spear = new Sprite('spear', sprite.x, sprite.y - sprite.radius * 2);
		dx = $cos(theta) * spear.v;
		dy = -$sin(theta) * spear.v;
		spear.locked_dxdy = [dx, dy];
		
		for (i = 0; i < 3; ++i) {
			// hack. move the spear a bit before adding it to the scene.
			spear.update();
		}
		this.sprites.add(spear);
		
	}
	
	function update(events, mx, my) {
		for (event : events) {
			if (event.is_gamepad && event.name == 'attack') {
				player_id = CONTEXT.config_id_to_game_id.get(event.device.id, null);
				if (player_id != null) {
					sprite = this.sprites_by_id.get(player_id, null);
					if (sprite.is_monster) {
						sprite.is_attacking = event.value;
					} else if (sprite.is_villager) {
						if (event.value && sprite.spear_cooldown < 0) {
							this.throw_spear(sprite);
						}
					}
				}
			}
		}
		
		for (device_id : this.device_ids_configured) {
			dir = $gamepad_get_state(device_id, 'dir');
			
			player_id = CONTEXT.config_id_to_game_id.get(device_id, null);
			if (player_id != null) {
				sprite = this.sprites_by_id.get(player_id, null);
				if (sprite != null) {
					sprite.dx = dir[0] * sprite.v;
					sprite.dy = dir[1] * sprite.v;
				}
			}
		}
		
		if (!this.monster.is_dead && this.monster.is_attacking) {
			if (this.counter % 3 == 0) {
				monster = this.monster;
				angle = 3.14159 * 2 / 8;
				theta = monster.theta + angle * ($random() - .5);
				fire = new Sprite('fire', monster.x, monster.y - .00001);
				dx = $cos(theta) * fire.v;
				dy = -$sin(theta) * fire.v;
				fire.locked_dxdy = [dx, dy];
				this.sprites.add(fire);
			}
		}
		
		new_sprites = [];
		spears = [];
		fires = [];
		villagers = [];
		
		for (sprite : this.sprites) {
			if (!sprite.is_dead) {
				sprite.update();
				if (!sprite.is_dead) {
					new_sprites.add(sprite);
					
					if (sprite.is_spear) {
						spears.add(sprite);
					} else if (sprite.is_fire) {
						fires.add(sprite);
					} else if (sprite.is_villager) {
						villagers.add(sprite);
					}
				}
			}
		}
		this.sprites = new_sprites;
		monsterx = this.monster.x;
		monstery = this.monster.y;
		monster_radius = this.monster.radius ** 2;
		for (spear : spears) {
			dist = (monsterx - spear.x) ** 2 + (monstery - spear.y) ** 2;
			if (dist < monster_radius) {
				spear.is_dead = true;
				this.monster.take_damage(0.01);
			}
		}
		
		
		vr = VILLAGER_RADIUS * 2;
		vr_squared = vr ** 2;
		for (fire : fires) {
			fire_x = fire.x;
			for (villager : this.villagers) {
				if (!villager.is_dead) {
					dx = $abs(villager.x - fire_x);
					if (dx < vr) {
						dist = (villager.y - fire.y) ** 2 + dx ** 2;
						if (dist < vr_squared) {
							fire.is_dead = true;
							if (villager.on_fire_counter < 0) {
								villager.on_fire_counter = FPS / 2;
							}
						}
					}
				}
			}
		}
		
		this.counter++;
	}
	
	function render_hud() {
		this.render_meter(this.monster, 0, 0, SCREEN_WIDTH, 25);
		for (i = 0; i < 7; ++i) {
			sprite = this.sprites_by_id['V' + (i + 1)];
			x = SCREEN_WIDTH * i / 7;
			x2 = SCREEN_WIDTH * (i + 1) / 7;
			this.render_meter(sprite, x, 25, x2 - x, 25);
		}
	}
	
	function render_meter(sprite, x, y, width, height) {
		$gfx_draw_rectangle(x, y, width, height, 0, 0, 0, 255);
		life = sprite.life_percent;
		if (life > 1) life = 1;
		else if (life < 0) life = 0;
		meter_width = $floor(life * (width - 2));
		color = sprite.color;
		$gfx_draw_rectangle(x + 1, y + 1, meter_width, height - 2, color[0], color[1], color[2], 255);
		color = sprite.dark_color;
		bottom = y + height - 2;
		$gfx_draw_rectangle(x + 1, bottom - 4, meter_width, 5, color[0], color[1], color[2], 255);
	}
	
	function render(rc) {
		$gfx_blit_image(this.bg, 0, 0);
		
		sorted_sprites = this.quick_sort(this.sprites);
		
		for (sprite : sorted_sprites) {
			sprite.window_bounds = this.bounds;
			sprite.render(rc);
		}
		
		this.render_hud();
	}
	
	function quick_sort(sprites) {
		if (sprites.length < 3) {
			if (sprites.length == 2) {
				if (sprites[0].y > sprites[1].y) return sprites[::-1];
			}
			return sprites;
		}
		
		pivot = sprites[0].y;
		left = [];
		right = [];
		for (i = sprites.length - 1; i > 0; --i) {
			sprite = sprites[i];
			if (sprites[i].y < pivot) {
				left.add(sprite);
			} else {
				right.add(sprite);
			}
		}
		left = this.quick_sort(left);
		right = this.quick_sort(right);
		output = left + [sprites[0]];
		output.concat(right);
		return output;
	}
}